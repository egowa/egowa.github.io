+++
title = 'git 이해하기 (1) (간단한 명령어, 커밋, 브랜치, HEAD)'
date = 2025-08-21T22:55:34+09:00
draft = false 
+++

![git svg 이미지](featured.png)

## git이란 무엇인가

git이란 버전 관리 프로그램 중 하나이다. 현재 가장 많이 사용되는 버전 관리 도구 중에 하나이다. git은 커밋이라는 단위로 버전을 관리하고, 브랜치라는 것을 새로 생성해서 버전의 분기점을 생성할 수 있다. 쉽게 설명하면 게임을 진행하다가 뭔가 실험적인 플레이를 해보고 싶은 생각이 들었다. 하지만 그 플레이가 잘못 되어서 게임을 망칠까봐 두려울 수 있다. 이럴 때 브랜치를 사용하면 여기서 분기점(base)가 생성되어 다양한 실험적인 플레이를 할 수 있는 경로가 생성된다. 만약 플레이가 만족스럽지 않으면 브랜치를 삭제할 수 있으며, 만약 플레이가 마음에 든다면 이 실험 환경을 실제 게임 환경에 합쳐줄 수도 있다. 커밋은 게임에서 세이브 파일에 대응된다고 생각할 수 있다. 세이브파일을 저장하면 이전에 세이브한 곳으로 돌아갈 수도 있고, 세이브 파일을 삭제할 수도 있고, 게임을 더 도전적으로 플레이할 수 있게 하고 더 안정적인 플레이를 할 수 있다. 한 번의 실수로 게임을 망치는 일도 없을 것이며, 만약 이전의 상황으로 돌아가야하는 상황에서 비효율적으로 시간을 쏟는 일도 사라질 것이다. 세이브파일을 로드하면 그만이기 때문이다.

지금까지는 게임으로 예시를 들기는 했지만, git은 게임의 세이브 기능보다도 더 강력할 수 있는 기능들을 제공한다. 필자도 git의 모든 기능에 대해서 알고 있지 못하고, 한 번씩 써볼 수는 있을 지도 의문이다. git은 개발자들 사이에서 필수 소양으로 여겨지고 있으니 이에 대한 나의 이해를 정리하면 도움이 될 것이라고 생각했다.

git의 특징은 여러 가지가 있다. git은 커밋을 작성하면 로컬 저장소에 저장된다. `git init` 을 입력하면 git 저장소가 새로 생성된다. git이라는 것이 매우 거창한 네트워크를 기반으로 작동하는 것은 아니다. git 저장소를 활성화한 디렉토리에서 `ls -a`를 입력해보면 .git 폴더가 있는 것을 확인할 수 있다. 우리가 git 명령어를 사용하면서 하는 일련의 행위들은 이 로컬에 있는 .git 폴더 안의 여러 파일들에 영향을 주면서 버전 관리를 하는 것이다. 물론 git은 로컬 저장소만 사용할 수 있는 것은 아니다. 원격 저장소에 저장소(repository)를 업로드할 수 있다. 많이들 들어봤을 GitHub가 git 원격 저장소 중에 하나이다. 원격 저장소에만 저장할 수는 없고 로컬 저장소에는 필수로 커밋들을 저장해야 한다. 

간략한 설명은 이 정도로 하고 구체적으로 git이 어떻게 동작하는 지를 구성요소별로 나눠서 이해해보자.

## git의 동작 원리

git을 이해하기 위해서는 3가지 구성 요소를 이해해야 하는데, 이는 다음과 같다. 

- Commit
- branch
- HEAD

### Commit

Commit이란 앞서 언급했던 게임에서의 세이브포인트이다. git 저장소에서 추적하는 모든 파일의 현재 상태를 스냅샷으로 저장한다. 이 commit이 기본 단위가 되어서 동작을 한다. 커밋의 구별자는 해시이며, 이것이 데이터베이스의 primary key라고 생각을 하면 된다.

게임에서는 세이브를 하면 바로 세이브 파일이 생성되지만, git에서는 커밋 이전에 한 가지 단계가 더 있다. 바로 staging이다. git에서는 커밋을 하기 전에 stage라는 곳에 파일을 등록해야 한다. 커밋을 하는 과정을 설명해본다면 다음과 같다.

1. 변경된 파일이나 새로운 파일을 스테이지에 올린다 (스테이징)
2. 스테이지에 올라와있는 파일들을 커밋한다. (커밋을 생성)

### branch

branch란 커밋들을 진행하다가 분기점을 만들어서 여러 사람이 같이 작업하거나 실험적인 기능을 구현하기 위한 환경을 마련할 수 있게 해주는 도구다. 

branch의 본질은 거창한 것이 아니고 커밋에 대한 정보만 담겨 있다. 즉, 커밋의 해시가 담겨있는 텍스트 파일에 불과하다. branch는 기본적으로 해당하는 branch에서의 가장 최신 커밋을 바라보고 있다.

git에서는 원래 master branch가 기본 branch로 설정되어있었는데 git 2.28 버전부터 main 이 기본 branch로 설정이 되어있다.

### HEAD

HEAD는 현재 작업 중인 위치를 나타낸다. branch와 마찬가지로 HEAD도 텍스트 파일이다. HEAD는 일반적으로 branch를 바라보고 있다. 커밋 자체를 바라보게 설정은 할 수 있다. 임시적으로 코드를 확인하는 등의 목적으로 사용이 가능한데, 이 상태에서 커밋을 하면 아무 branch도 해당 커밋을 바라보고 있지 않은 상태가 되므로 이 커밋은 고아 커밋이 된다. (HEAD가 branch가 아닌 별도의 커밋을 바라보고 있는 상태를 detached HEAD 라고 한다.) 고아 커밋이 있으면 git에서 자체적으로 경고 문구를 띄워준다. 이 상태에서는  다른 브랜치에서 해당 커밋을 찾기 어려우며 (커밋의 해시값을 알고 있으면 찾을 수 있지만 해시를 모르면 복잡해진다.) 고아 커밋은 주기적인 garbage collection에 의한 삭제 대상이 된다. (기본값은 30일이다.) 이 문제를 해결하기 위해서는 별도의 브랜치를 생성해서 해당 커밋을 바라보도록 설정해주면 된다. 

이 정도를 알고 있으면 git 명령어를 이해하는 데에 큰 어려움이 없을 것이다. 이제 git 명령어에 대해서 설명을 해보겠다.

## git 명령어에 대한 이해

이 글에 언급된 것 외에도 git 명령어는 매우 많다. man 페이지를 확인하거나 git manual을 인터넷에 검색해서 찾아보면 더 많은 옵션을 확인할 수 있다.

```
git add (파일)
```

파일을 스테이징하는 명령어이다. 예를 들어 `git add test.txt` 명령어를 사용하면 test.txt 파일을 스테이지에 올린다. 모든 변경사항과 새로운 파일을 한 번에 스테이징하고 싶다면 `git add .` 명령어를 사용하면 된다.

```
git commit
```

스테이징된 파일들을 커밋하는 명령어이다. 입력하면 텍스트 에디터가 뜨며, 커밋 메시지(게임에서 세이브를 할 때 메모를 남기는 기능같은 것)를 입력할 수 있다. 만약 별도의 텍스트 에디터가 뜨는 것을 원치 않고 바로 커밋 메시지를 추가해주고 싶다면 `git commit -m "커밋 메시지"` 명령어를 사용하자.

```
git push
```

로컬 저장소에 저장되어있는 커밋들을 원격 저장소에 올리는 명령어다.

```
git pull
```

`git fetch` 와 `git merge`가 합쳐진 명령어이다. `git fetch` 는 원격 저장소의 커밋들을 로컬 저장소에 가져와서 원격 추적 브랜치를 업데이트하는 명령어이다. 예를 들어 만약 원격 저장소의 main 브랜치의 커밋들을 로컬 저장소에 가져온다고 하면 origin/main 라는 원격 추적 브랜치가 업데이트된다.

`git merge <branch name>` 으로 구성되는 merge 기능은 대상 branch를 현재 HEAD가 가리키는 branch에 병합시키는 기능이다. 즉 별도로 나눠져 있던 분기점을 하나로 합치는 명령어이다.

이 명령어가 결합되어, `git pull`은 원격 저장소에서 커밋들을 가져와 로컬의 브랜치(주로 main)에 병합하는 명령어인 것이다.

이 정도면 기본적인 명령어는 익힌 셈이다. 조금 더 어려운 명령어는 다음 글에서 작성하도록 하겠다.
